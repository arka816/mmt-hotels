# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MMTHotelsDialog
                                 A QGIS plugin
 downloads current hotel prices with geotags and reviews and stores them in mongodb 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-01-17
        git sha              : $Format:%H$
        copyright            : (C) 2023 by arka
        email                : arkaprava.mail@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys

sys.path.append(os.path.dirname(__file__))

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
from qgis.PyQt.QtCore import QObject, QThread, pyqtSignal, QVariant
from qgis.core import QgsVectorLayer, QgsFeature, QgsGeometry, QgsPointXY, QgsProject, QgsField, QgsMarkerSymbol

from PyQt5.QtWebKitWidgets import QWebView

from scraper import MMTWorker


import pandas as pd


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mmt_hotels_dialog_base.ui'))


class MMTHotelsDialog(QtWidgets.QDialog, FORM_CLASS):
    __HOTEL_LOAD_PROGRESS = 10
    __DRAW_LAYER_PROGRESS = 10

    def __init__(self, parent=None):
        """Constructor."""
        super(MMTHotelsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # initialize flags and qt elements
        # set download in progress flag as false
        self.isDownloadInProgress = False

        self.result_count = 0

        self.progress_bar.setMaximum(100)

        self.elem_config_map = {
            'KEYWORD' : self.keyword,
            'IMAGE_DIR': self.image_dir,
            'MAX_HOTELS': self.max_hotels,
            'MAX_REVIEWS': self.max_reviews,
            'SAVE_IMAGES': self.save_images,
            'TABLE_NAME': self.tablename,
            'DB_NAME': self.dbname
        }

        self.configFilePath = os.path.normpath(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".conf"))

        # connect buttons to handlers
        self.start_btn.clicked.connect(self._start_download_thread)
        self.stop_btn.clicked.connect(self._stop_download_thread)
        self.image_dialog_btn.clicked.connect(self._select_output_folder)
        self.remove_layers_btn.clicked.connect(self._remove_layers)
        self.close_windows_btn.clicked.connect(self._close_browser_windows)

        self._load_prev_input()
        self._cleanup()


    def _select_output_folder(self):
        outputDir = QFileDialog.getExistingDirectory(self, "choose output directory")
        self.image_dir.setText(outputDir)

    def _save_input(self):
        try:
            f = open(self.configFilePath, 'w')
        except:
            return
        
        l = list()

        for key, val in self.elem_config_map.items():
            if key == 'SAVE_IMAGES':
                l.append(f"{key}={'true' if val.isChecked() else 'false'}")
            else:
                l.append(f"{key}={val.text()}")

        f.write('\n'.join(l))
        f.close()
        return

    def _load_prev_input(self):
        if os.path.exists(self.configFilePath):
            # load configurations from configfile
            try:
                f = open(self.configFilePath)
            except:
                self.logBox.append("Error: could not load from config file.")
                return

            for line in f.readlines():
                key, val = line.strip('\n').split("=")
                elem = self.elem_config_map[key]

                if key == 'SAVE_IMAGES':
                    elem.setChecked(val == "true")
                else:    
                    elem.setText(val)

            f.close()
            return
        
    def _close_browser_windows(self):
        if hasattr(self, 'webViews'):
            for webView in self.webViews:
                try:
                    webView.close()
                except:
                    pass

    def _remove_layers(self):
        try:
            QgsProject.instance().removeMapLayers([self.boundaryLayer.id(), self.markerLayer.id()])
            QgsProject.instance().refreshAllLayers()
        except:
            pass

    def _cleanup(self):
        # set logbox empty
        self.log_box.setPlainText("")

        # set progress bar to zero
        self.progress_bar.setValue(0)

        # disable stop button
        self.stop_btn.setEnabled(False)

        # clean vector layer
        self._remove_layers()

        # close open browser windows
        self._close_browser_windows()

    def _start_download_thread(self):
        self._cleanup()

        def int_error(elem, elem_name):
            QMessageBox.warning(self, "Error", f"{elem_name} is not numeric")
            elem.setFocus()
            elem.selectAll()

        def path_error(elem, path):
            QMessageBox.warning(self, "Error", f"the specified path {path} does not exist or is not a directory")
            elem.setFocus()
            elem.selectAll()

        def empty_error(elem, elem_name):
            QMessageBox.warning(self, "Error", f"{elem_name} can not be empty")
            elem.setFocus()

        if not self.isDownloadInProgress:
            # collect and clean data from input
            try:
                max_hotels = int(self.max_hotels.text())
            except:
                int_error(self.max_hotels, "MAX_HOTELS")

            try:
                max_reviews = int(self.max_reviews.text())
            except:
                int_error(self.max_reviews, "MAX_REVIEWS")

            image_dir = self.image_dir.text()
            if not os.path.exists(image_dir) or not os.path.isdir(image_dir):
                path_error(self.image_dir, image_dir)

            keyword = self.keyword.text()
            dbname = self.dbname.text()
            tablename = self.tablename.text()

            if len(keyword) == 0:
                empty_error(self.keyword, "Keyword")
            
            if len(dbname) == 0:
                empty_error(self.dbname, "Database name")
            
            if len(tablename) == 0:
                empty_error(self.tablname, "Table name")

            save_images = self.save_images.isChecked()

            if {'max_reviews', 'max_hotels'} <= set(locals()) and len(keyword) > 0 and len(dbname) > 0 and len(tablename) > 0:
                self.isDownloadInProgress = True     

                # enable and disable start and stop buttons
                self.start_btn.setEnabled(False)
                self.stop_btn.setEnabled(True) 

                # create worker
                self.thread = QThread()
                self.worker = MMTWorker(keyword, dbname, tablename, max_hotels, max_reviews)
                self.worker.moveToThread(self.thread)

                # connect signals to slots
                self.worker.addMessage.connect(self._message_from_worker)
                self.worker.addError.connect(self._error_from_worker)
                self.worker.progress.connect(self._progress_from_worker)
                self.worker.total.connect(self._total_from_worker)

                self.thread.started.connect(self.worker.run)
                self.worker.finished.connect(self.thread.quit)
                self.worker.finished.connect(self.worker.deleteLater)
                self.thread.finished.connect(self.thread.deleteLater)

                # start thread and run worker
                self.thread.start()

                # enable button after thread finishes; set download not in progress
                def worker_finished(review_data): 
                    self.start_btn.setEnabled(True)    
                    self.stop_btn.setEnabled(False)
                    self.isDownloadInProgress = False
                    self.progress_bar.setValue(self.progress_bar.maximum())  

                    if type(review_data) == list and len(review_data) > 0:    
                        self.review_data = review_data
                    
                self.worker.finished.connect(worker_finished)  
            else:
                QMessageBox.warning(self, "Error", "Can not download without appropriate data!")
      
    def _stop_download_thread(self):
        self.worker.stop()

    def _message_from_worker(self, message):
        self.log_box.append(message)

    def _error_from_worker(self, message):
        QMessageBox.warning(self, "Error", message)

    def _progress_from_worker(self, progress):
        self.progress_bar.setValue(
            self.__HOTEL_LOAD_PROGRESS + 
            (100 - self.__HOTEL_LOAD_PROGRESS - self.__DRAW_LAYER_PROGRESS) * progress / self.result_count
        )

    def _total_from_worker(self, total):
        self.result_count = total
        self.progress_bar.setValue(self.__HOTEL_LOAD_PROGRESS)
